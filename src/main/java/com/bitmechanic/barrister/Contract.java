package com.bitmechanic.barrister;

import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.List;
import java.io.InputStream;
import java.util.Map;
import java.util.HashMap;

/**
 * A Contract represents a single Barrister IDL file.  It contains all the
 * Interfaces, Structs, and Enums defined in the file.
 *
 * Currently the internal Struct, Enum, and Interface definitions are exposed
 * via getters.  No effort has been made to enforce immutability, but if you mutate
 * this state, we hope you have a VERY good reason for doing so.  
 *
 * Note that when "IDL File" is referred to in this doc, we're referring to the 
 * JSON representation of the IDL as generated by the barrister tool, not the 
 * human readable text version.
 */
public class Contract extends BaseEntity {

    /**
     * Loads the IDL JSON file, parses it, and returns a Contract.
     * Uses the JacksonSerializer.
     *
     * @param idlJson Barrister IDL JSON file to load
     * @return Contract based on the IDL JSON file
     * @throws IOException If there is a problem reading the file, or if JSON 
     *         deserialization fails
     */
    public static Contract load(File idlJson) throws IOException {
        FileInputStream fis = new FileInputStream(idlJson);
        Contract c = load(fis);
        fis.close();
        return c;
    }

    /**
     * Loads the IDL JSON from the given stream, parses it, and returns a Contract.
     * Uses the JacksonSerializer.
     *
     * @param idlJson InputStream of the IDL JSON to parse
     * @return Contract based on the IDL JSON stream
     * @throws IOException if there is a problem reading the stream, or if JSON
     *         deserialization fails
     */
    public static Contract load(InputStream idlJson) throws IOException {
        return load(idlJson, new JacksonSerializer());
    }

    /**
     * Loads the IDL from the given stream using an arbitrary serializer and returns
     * a Contract.
     *
     * @param idlJson Stream containing serialized IDL
     * @param ser Serializer implementation to use
     * @return Contract based on the IDL stream
     * @throws IOException if there is a problem reading the stream, or if deserialization fails
     */
    @SuppressWarnings("unchecked")
    public static Contract load(InputStream idlJson, Serializer ser) throws IOException {
        return new Contract(ser.readList(idlJson));
    }

    //////////////////////////////

    private Map<String, Interface> interfaces;
    private Map<String, Struct> structs;
    private Map<String, Enum> enums;
    private Map<String, Object> meta;

    private List<Map<String,Object>> idl;

    private String packageName;
    private String nsPackageName;

    public Contract() {
        interfaces = new HashMap<String, Interface>();
        structs    = new HashMap<String, Struct>();
        enums      = new HashMap<String, Enum>();
        meta       = new HashMap<String, Object>();
    }

    /**
     * Creates a new Contract based on the Map representation of the IDL
     */
    public Contract(List<Map<String,Object>> idl) {
        this();
        this.idl = idl;
        this.meta = new HashMap<String, Object>();

        for (Map<String,Object> e : idl) {
            String type = String.valueOf(e.get("type"));
            if (type.equals("interface")) {
                Interface i = new Interface(e);
                i.setContract(this);
                interfaces.put(i.getName(), i);
            }
            else if (type.equals("struct")) {
                Struct s = new Struct(e);
                s.setContract(this);
                structs.put(s.getName(), s);
            }
            else if (type.equals("enum")) {
                Enum en = new Enum(e);
                en.setContract(this);
                enums.put(en.getName(), en);
            }
            else if (type.equals("meta")) {
                for (Map.Entry<String, Object> entry : e.entrySet()) {
                    if (!entry.getKey().toString().equals("type")) {
                        meta.put(entry.getKey().toString(), entry.getValue());
                    }
                }
            }
        }
    }

    /**
     * Sets the Java package associated with this Contract. This is 
     * used to resolve full generated Java class names when unmarshaling data
     * from requests.
     */
    public void setPackage(String pkgName) {
        this.packageName = pkgName;
    }
    
    /**
     * Returns the Java package associated with this Contract
     */
    public String getPackage() {
        return packageName;
    }

    /**
     * Sets the base Java package for namespaced entities associated with this Contract. 
     * This is used instead of getPackage() for entities that are namespaced. 
     */
    public void setNsPackage(String pkgName) {
        this.nsPackageName = pkgName;
    }
    
    /**
     * Returns the base Java package for namespaced entities associated with this Contract.
     * If no nsPackage is set, this method returns the same value as getPackage().
     */
    public String getNsPackage() {
        return (nsPackageName == null) ? getPackage() : nsPackageName;
    }

    /**
     * Returns a fully qualified class name for the given struct/enum/interface
     * name.  If the name is namespaced, nsPackage is used.  Otherise package is
     * used to prefix the name.
     */
    public String getClassNameForEntity(String name) {
        if (name.indexOf(".") > -1)
            return getNsPackage() + "." + name;
        else
            return getPackage() + "." + name;
    }

    /**
     * Returns the IDL associated with this Contract as passed to the constructor.
     */
    public List<Map<String,Object>> getIdl() {
        return idl;
    }

    /**
     * Returns values from the IDL "meta" element
     */
    public Map<String, Object> getMeta() {
        return meta;
    }

    /**
     * Returns the interfaces associated with this Contract. 
     * Keys: interface name from IDL.  Value: Interface instance.
     */
    public Map<String, Interface> getInterfaces() {
        return interfaces;
    }

    /**
     * Returns the structs associated with this Contract. 
     * Keys: struct name from IDL.  Value: Struct instance.
     */
    public Map<String, Struct> getStructs() {
        return structs;
    }

    /**
     * Returns all Structs that extend this Struct, and their
     * descendatnts, recursively.
     */
    public List<Struct> getStructDescendants(Struct struct) {
        return getStructDescendants(struct, new ArrayList<Struct>());
    }

    private List<Struct> getStructDescendants(Struct struct, List<Struct> list) {
        for (Struct s : structs.values()) {
            if (s.getExtends() != null && s.getExtends().equals(struct.getName())) {
                list.add(s);
                getStructDescendants(s, list);
            }
        }

        return list;
    }

    /**
     * Returns the enums associated with this Contract. 
     * Keys: enum name from IDL.  Value: Enum instance.
     */
    public Map<String, Enum> getEnums() {
        return enums;
    }

    /**
     * Returns the Function associated with the given interface and function name.
     *
     * @param iface Interface name
     * @param func Function name in the interface
     * @return Function that matches iface and func on this Contract
     * @throws RpcException If no Function matches
     */
    public Function getFunction(String iface, String func) throws RpcException {
        Interface i = interfaces.get(iface);
        if (i == null) {
            String msg = "Interface '" + iface + "' not found";
            throw RpcException.Error.METHOD_NOT_FOUND.exc(msg);
        }

        Function f = i.getFunction(func);
        if (f == null) {
            String msg = "Function '" + iface + "." + func + "' not found";
            throw RpcException.Error.METHOD_NOT_FOUND.exc(msg);
        }

        return f;
    }

}